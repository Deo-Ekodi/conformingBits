linux-drivers
=============

>Device Files
	-Everything is a file(devices inclusive)
	-devices are located in /dev direrctory
	-devices have major / minor numbers (allocated statically in '''devices.txt''') and also dynamically
	-user space is exposed to (char, block and network) devices and some are abstract
	-
	-
	-
	-
	-
>Major & Minor Numbers
	-each device instance has major(char & block drivers) & minor numbers(device instance)
	-minor number not recognized by kernel(only used by driver)
	-
	-
> /proc & procfs
	- '/proc' is a virtual filesystem of type procfs -> (all files & directories in /proc (exist in memory))
	- '/proc' is used to import useful info from kernel - used byb subsystems, drivers & core functionality (just like a mess)
	-
	-
> /sys & sysfs	
	-new way of exporting kernel info to user-space
	-will eventually replace /proc
	-contains multiple views of same hardware :
		>bus view(/sys/bus)
		>device view(/sys/devices)
		>class view(/sys/class)
	-
	-
	-
> /dev & udev	
	-main repo for device nodes
	-udev dynamically creates entries in /dev
	-can be configured to provide persistent view
	-
	-


Kernel Resources
>printk
	-equivalent of libc's printf()
	>KERN_EMERG		- urgent messages before crash
	>KERN_ALERT		- Alert for immediate action
	>KERN_CRIT		- Critical issues
	>KERN_ERR		- important error
	>KERN_NOTICE	- normal
	>KERN_WARNING	- non-critical warnings
	>KERN_INFO		- informational
	>KERN_DEBUG		- debugging messages

	-since overuse of printk is unprofessional, use 'printk_ratelimit()' to moderate
	-
	-
> /proc
	-helps avoid syslog overhead
	-seq files - <linux/seq_file.h>
	-
	-
	-

Types of Drivers
================
>char device driver
>block device driver
>network device driver
>MTD map file
>Framebuffer driver	

(i)		char drivers
		============
	>major and minor numbers
		-available in <linux/fs.h>
		-device nodes available in '/dev'
		-major/minor tuples are provided for each device
		-one major number(20 bit) 	= one device type
		-minor number(12 bit)		= device instance
		-kernel always ignores minor number
		-device numbers are internally represented in 'dev_t'
		-	<linux/kdev_t.h>
		-these numbers can be statically or dynamically allocated
		-deallocation must be done afterwards

	>file operations structure
		-provides connection between major and minor numbers to char driver callbacks
		-	'''struct file_operations'''
		-	<linux/fs.h>
		-file_operations are actual implementation of main filesystem calls :
			open, close, read, write ...
		-NULL for unsupported calls

	>file structure
		-	<linux/fs.h>
		-represents an open file
		-released once all file instances are closed

		>inode structure
		-kernel internal representation of files
		-access inode fields using macros
		
		>char device registration
		-must allocate 'struct cdev' so kernel can call char device callbacks
		-use a device-specific struct which contains 'struct cdev' as one of its elements
		-Must set the owner
		-Must add device to system (both ststic and dynamic)

	>older way char device registration

	>open and release
		open should
		-identify device being opened
		-check for device-specific errors
		-initialize device if first open
		-update file_operations if necessary
		release should
		-close()
		-shutdown device on last close

	>read and write
		-copy_to_user and copy_from_user		

	>read
		-interpretation of return value by user space
		-bytes == count, transfer success
		-count > bytes > 0, application retries
		-bytes == o, end-of-file
		-bytes < 0, errno => errno from <linux/errno.h>
		-if data == NULL, read() should block

	>write
		-interpretation of return value by user space
		-bytes == count, transfer success
		-count > bytes > 0, application retries
		-bytes == o, no error .. retry
		-bytes < 0, errno => errno from <linux/errno.h>	

	>readv/writev
		-vector operations
		-vectors contain : buffer + length value
		-if missing, r/w are called multiple times by kernel
		-easiest, have a loop in driver calling read/write

	>ioctl
		-must be able to control device with more than just read/write
		-some implementations open unauditable back-doors to drivers
		-	<linux/asm/ioctl.h>	// implements "magic numbers" split up in several bitfields
	-

	>blocking i/o
		-what if a driver can't satisfy read() / write()?
		-> it must be able to put calling process to sleep
		sleeping
		-never sleep in a critical section
		-never sleep with interrupts disabled
		-on wakeup, no time or event context, recheck sleep condition
		-never sleep if waking procedure is not sure
		-a 'wait queue' contsins list of sleeping processes
		-processes are woken up by interrupts
		-wait queues in 	<linux/wait.h>
		-process of sleeping :
			...allocate, initialize and pend wait queue query
			...set task state
			...call scheduler

	>poll and select
		-non-blocking i/o operations use poll, select and epoll to determine if data is ready for consumption
		-checks file descriptors if one of them is ready for read/write or wait for read/write
		-	<linux/poll.h>

	>fsync
		-flushes pending output
		-fsync() doesn't return until all data is flushed to device

	>fasync
		-asynchronous notification

	>llseek
		-seek a device
		-must cooperate with r/w
		-	<linux/fs.h>

	>access control on a device file
		-only one process can open a device
		-accessed by single user at a time - allows user to open device multiple times
	
(ii)	block drivers
		=============
	>registration
		-	<linux/fs.h>
		-block driver registration
		-disk registration

	>block device operations
		-open() and release() methods
		-ioctl

	>request processing
		-core block of i/o
		-every block driver must have request queue
		-request queues
			stores requests
			should present only valid requests
		-	<linux/blkdev.h>?? does exist??
		-check queuing functions
		-queue control functions
		-check anatomy of a request(biostructure, helper functions)
		-request structure fields
		-barrier requests
		-nonretryable requests
		-request comppletion functions

	>extras
	-command pre-preparation - get info about pending request prior to it being returned
	-some hardware supports having multiple requests running in parallel

(iii)	network drivers
		===============
	>introduction
	>connecting to the kernel
	>net_device structure
	>open and close
	>packet transmission
	>packet reception
	>interrupt handler
	>receive interrupt mitigation
	>changes in link state
	>socket buffers
	>MAC address resolution
	>custom 'ioctl' commands
	>statistical information
	>extras
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	--
	
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	-
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
